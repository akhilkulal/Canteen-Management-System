 var validator = require('validator')

 var default_options = {
     tag: 'danger'
 }

class ValidatorWrapper {

    constructor(){
        this.ctx = {
            stopNext: false,
            content: '',
            messages: [],
            method: '',
            method_args: [],
            options : default_options
        };
    }
 

    get messages(){
        return this.ctx.messages;
    }

    get validator(){
        return validator;
    }

    options(options){

        this.ctx.options.tag = options.tag || default_options.tag
    }


    pick(content){
        content = (content || '') + ''
        this.ctx.content = content
        this.ctx.stopNext = false
        this.ctx.messages = []
        return this;
    }
    
    pickNext(content) {
        content = (content || '') + ''
        this.ctx.content = content
        this.ctx.stopNext = false
        return this;
    }

    length(options, message, tag){     
        return (this.ctx.stopNext)? this : this.setMessage(!validator.isLength(this.ctx.content, options), message, tag)
    }

    custom(condition, message, tag) {
        return (this.ctx.stopNext) ? this : this.setMessage(condition, message, tag);
    }

    email(message, tag){
        return (this.ctx.stopNext) ? this : this.setMessage(!validator.isEmail(this.ctx.content), message, tag)
    }

    empty(message, tag){
        var empty = validator.isEmpty(this.ctx.content);
        
        this.setMessage(empty, message, tag)
        this.ctx.stopNext = empty;
        
        return this;
    }

    equals(target, message, tag){
        return (this.ctx.stopNext) ? this : this.setMessage(validator.equals(target, this.ctx.content), message, tag)
    }

    diff(target, message, tag){
        return (this.ctx.stopNext) ? this : this.setMessage(!validator.equals(target, this.ctx.content), message, tag)
    }

    
    test(regex, message, tag){
        return (this.ctx.stopNext) ? this : this.setMessage(!regex.test(this.ctx.content), message, tag)
    }

    prepare(){
        var method = arguments[0]
        if (validator[method] === undefined)  throw new Error('Method not found')

        this.ctx.method = method
        
        this.ctx.method_args = []
        this.ctx.method_args = [...arguments].slice(1)

        return this;
    }
    
    f(){
        return this.prepare.apply(this, arguments);
    }

    eval(message, tag){
        if (this.ctx.method === '' || this.ctx.stopNext) return this;

        var ret = validator[this.ctx.method](this.ctx.content, ...this.ctx.method_args)

        return this.setMessage(!ret, message, tag);
    }

    x(message, tag){
        return this.eval(message, tag)
    }

    setMessage(condition, message, tag){

        if (this.ctx.stopNext)  return this;

        tag = tag || this.ctx.options.tag
        if (condition && message){
            this.ctx.messages.push({message: message, tag: tag})
        }

        return this;
    }
}

module.exports = new ValidatorWrapper()